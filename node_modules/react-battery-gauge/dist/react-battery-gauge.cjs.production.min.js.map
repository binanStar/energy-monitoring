{"version":3,"file":"react-battery-gauge.cjs.production.min.js","sources":["../src/lib/constants/index.ts","../src/lib/store/context.ts","../src/lib/hooks/useGaugeContext.ts","../src/lib/hooks/useBatteryDimensions.ts","../src/lib/components/Battery/index.tsx","../src/lib/store/Provider.tsx","../src/lib/Canvas.tsx","../src/lib/hooks/useLevelDimensions.ts","../src/lib/utils/index.ts","../src/lib/components/BatteryLevel.tsx","../src/lib/components/ReadingText.tsx","../src/lib/hooks/useCounterAnimation.ts","../src/lib/components/Charging.tsx","../src/index.tsx","../src/lib/hooks/useClipPathHash.ts"],"sourcesContent":["export const CANVAS_WIDTH = 100;\nconst CANVAS_HEIGHT = 52;\n\nexport const BATTERY_ASPECT_RATIO = CANVAS_HEIGHT / CANVAS_WIDTH; // battery is horizontal\nexport const BATTERY_BODY = 'batteryBody';\nexport const BATTERY_CAP = 'batteryCap';\nexport const BATTERY_METER = 'batteryMeter';\nexport const READING_TEXT = 'readingText';\nexport const CHARGING_FLASH = 'chargingFlash';\n\n// clipPath ids\nexport const CLIP_METER = 'clip_level_meter';\nexport const CLIP_METER_FILLED = 'clip_level_meter_filled';\nexport const CLIP_METER_EMPTY = 'clip_level_meter_empty';\nexport const CLIP_CAP = 'battery_cap_clip';\n","import { BATTERY_ASPECT_RATIO, CANVAS_WIDTH } from './../constants/index';\nimport { createContext } from 'react';\nimport type { TGaugeCanvas } from '../../typings';\n\nexport const defaultState = {\n  canvasWidth: CANVAS_WIDTH,\n  canvasHeight: CANVAS_WIDTH * BATTERY_ASPECT_RATIO,\n  aspectRatio: BATTERY_ASPECT_RATIO,\n  padding: 0,\n  value: 50,\n  maxValue: 100,\n  clipPathHash: '',\n  orientation: 'horizontal' as TGaugeCanvas['orientation'],\n  animated: false,\n  charging: false,\n  customization: {\n    batteryBody: {\n      strokeWidth: 4,\n      cornerRadius: 6,\n      fill: 'none',\n      strokeColor: '#111',\n    },\n    batteryCap: {\n      fill: 'none',\n      strokeWidth: 4,\n      strokeColor: '#111',\n      cornerRadius: 2,\n      capToBodyRatio: 0.4,\n    },\n    batteryMeter: {\n      fill: 'green',\n      lowBatteryValue: 15,\n      lowBatteryFill: 'red',\n      outerGap: 1,\n      noOfCells: 1,\n      interCellsGap: 1,\n    },\n    readingText: {\n      lightContrastColor: '#111',\n      darkContrastColor: '#fff',\n      lowBatteryColor: 'red',\n      fontFamily: 'Helvetica',\n      fontSize: 14,\n      showPercentage: true,\n    },\n    chargingFlash: {\n      scale: undefined,\n      fill: 'orange',\n      animated: true,\n      animationDuration: 1000,\n    },\n  },\n};\n\nexport const Context = createContext<TGaugeCanvas>(defaultState);\n","import { ContextType, useContext } from 'react';\nimport { Context } from '../store/context';\n\nexport function useGaugeContext() {\n  return useContext(Context);\n}\n\nexport type UseGaugeContextReturnValue = ContextType<typeof Context>;\n","import { useGaugeContext } from './useGaugeContext';\n\nexport const useBatteryDimensions = (batteryCapRatio: number) => {\n  const { canvasHeight, canvasWidth, padding } = useGaugeContext();\n  const objectHeight = canvasHeight - 2 * padding; // total canvas height minus vertical padding\n  const capHeight = objectHeight * batteryCapRatio;\n  const capWidth = capHeight / 2;\n\n  return {\n    bodyWidth: canvasWidth - capWidth - 2 * padding,\n    bodyHeight: canvasHeight - 2 * padding,\n    capWidth,\n    capHeight,\n  };\n};\n","import React from 'react';\nimport { BATTERY_BODY, BATTERY_CAP, CLIP_CAP } from '../../constants';\nimport { useBatteryDimensions } from '../../hooks/useBatteryDimensions';\nimport { useGaugeContext } from '../../hooks/useGaugeContext';\n\nexport const Battery = () => {\n  const {\n    canvasWidth,\n    canvasHeight,\n    padding,\n    customization,\n    clipPathHash,\n  } = useGaugeContext();\n\n  const {\n    strokeColor: bodyStrokeColor,\n    strokeWidth: bodyStrokeWidth,\n    fill: bodyFill,\n    cornerRadius: bodyCornerRadius,\n  } = customization[BATTERY_BODY];\n\n  const {\n    strokeColor: capStrokeColor,\n    strokeWidth: capStrokeWidth,\n    fill: capFill,\n    cornerRadius: capCornerRadius,\n    capToBodyRatio,\n  } = customization[BATTERY_CAP];\n\n  const { bodyWidth, bodyHeight, capWidth, capHeight } = useBatteryDimensions(\n    capToBodyRatio\n  );\n  return (\n    <g>\n      <defs>\n        <clipPath id={CLIP_CAP + clipPathHash}>\n          <rect\n            x={canvasWidth - padding - capWidth}\n            y={(canvasHeight - capHeight - capStrokeWidth) / 2}\n            width={capWidth}\n            height={capHeight + capStrokeWidth}\n            strokeWidth={capStrokeWidth}\n          />\n        </clipPath>\n      </defs>\n      <rect\n        className={BATTERY_BODY}\n        x={padding}\n        y={padding}\n        rx={bodyCornerRadius}\n        ry={bodyCornerRadius}\n        width={bodyWidth}\n        height={bodyHeight}\n        strokeWidth={bodyStrokeWidth}\n        fill={bodyFill}\n        stroke={bodyStrokeColor}\n      />\n      <rect\n        clipPath={`url(#${CLIP_CAP + clipPathHash})`}\n        className={BATTERY_CAP}\n        x={canvasWidth - padding - capWidth - capCornerRadius}\n        y={(canvasHeight - capHeight) / 2}\n        rx={capCornerRadius}\n        ry={capCornerRadius}\n        width={capWidth}\n        height={capHeight}\n        strokeWidth={capStrokeWidth}\n        fill={capFill}\n        stroke={capStrokeColor}\n      />\n    </g>\n  );\n};\n","import React, { FC } from 'react';\nimport type { TGaugeCanvas } from '../../typings';\nimport { Context } from './context';\n\ninterface Props {\n  value: TGaugeCanvas & { clipPathHash: string };\n}\n\nexport const CanvasProvider: FC<Props> = ({ children, value }) => {\n  return <Context.Provider value={value}>{children}</Context.Provider>;\n};\n","import React from 'react';\nimport { TGaugeCanvas } from '../typings';\nimport { CanvasProvider } from './store/Provider';\n\nexport interface TCanvasProps\n  extends Omit<React.SVGProps<SVGSVGElement>, 'orientation'>,\n    TGaugeCanvas {}\n\nexport const Canvas = (props: TCanvasProps) => {\n  const {\n    children,\n    canvasWidth,\n    canvasHeight,\n    padding,\n    value,\n    maxValue,\n    orientation,\n    customization,\n    clipPathHash,\n    ...otherSvgProps\n  } = props;\n  return (\n    <CanvasProvider\n      value={{\n        canvasWidth,\n        canvasHeight,\n        padding,\n        value,\n        maxValue,\n        orientation,\n        customization,\n        clipPathHash,\n      }}\n    >\n      <svg viewBox={`0 0 ${canvasWidth} ${canvasHeight}`} {...otherSvgProps}>\n        {children}\n      </svg>\n    </CanvasProvider>\n  );\n};\n","import { BATTERY_CAP, BATTERY_METER, BATTERY_BODY } from './../constants/index';\nimport { useMemo } from 'react';\nimport { useBatteryDimensions } from './useBatteryDimensions';\nimport { useGaugeContext } from './useGaugeContext';\n\nexport const useLevelDimensions = () => {\n  const { padding, customization } = useGaugeContext();\n  const { strokeWidth } = customization[BATTERY_BODY];\n  const { capToBodyRatio } = customization[BATTERY_CAP];\n  const { outerGap } = customization[BATTERY_METER];\n  const { bodyWidth, bodyHeight } = useBatteryDimensions(capToBodyRatio);\n\n  return useMemo(() => {\n    const innerBodyWidth = bodyWidth - strokeWidth;\n    const innerBodyHeight = bodyHeight - strokeWidth;\n    return {\n      x: padding + strokeWidth / 2 + outerGap,\n      y: padding + strokeWidth / 2 + outerGap,\n      width: innerBodyWidth - 2 * outerGap,\n      height: innerBodyHeight - 2 * outerGap,\n    };\n  }, [bodyWidth, bodyHeight, outerGap, padding, strokeWidth]);\n};\n","export function getValueInPercentage(value: number, maxValue: number) {\n  return Math.round((value / maxValue) * 100);\n}\n\nexport function checkLowBattery(value: number, lowBatteryValue: number) {\n  return value < lowBatteryValue;\n}\n\nexport function getVisibleCellsCount(\n  value: number,\n  maxValue: number,\n  noOfCells: number\n) {\n  return Math.floor(Math.abs(value / maxValue) * noOfCells);\n}\nexport const timing = (progress: number, easing?: 'linear') => {\n  if (easing === 'linear') {\n    return progress;\n  }\n  return progress;\n};\n","import React, { useMemo } from 'react';\nimport {\n  BATTERY_BODY,\n  BATTERY_METER,\n  CLIP_METER,\n  CLIP_METER_FILLED,\n} from '../constants';\nimport { useGaugeContext } from '../hooks/useGaugeContext';\nimport { useLevelDimensions } from '../hooks/useLevelDimensions';\nimport { checkLowBattery, getVisibleCellsCount } from '../utils';\n\nexport const BatteryLevel = () => {\n  const { value, maxValue, customization, clipPathHash } = useGaugeContext();\n  const { x, y, width, height } = useLevelDimensions();\n  const {\n    fill,\n    lowBatteryFill,\n    gradFill,\n    lowBatteryValue,\n    outerGap,\n    noOfCells,\n    interCellsGap,\n  } = customization[BATTERY_METER];\n  const {\n    strokeWidth: bodyStrokeWidth,\n    cornerRadius: bodyCornerRadius,\n  } = customization[BATTERY_BODY];\n\n  const cellList = useMemo(() => {\n    const noOfVisibleCells = getVisibleCellsCount(value, maxValue, noOfCells);\n    if (noOfVisibleCells === 0 && value > 0) {\n      return ['cell'];\n    }\n    return new Array(noOfVisibleCells).fill('cell');\n  }, [value, maxValue, noOfCells]);\n\n  return (\n    <g>\n      <defs>\n        <clipPath id={CLIP_METER + clipPathHash}>\n          <rect\n            x={x}\n            y={y}\n            rx={bodyCornerRadius - bodyStrokeWidth / 2 - outerGap}\n            ry={bodyCornerRadius - bodyStrokeWidth / 2 - outerGap}\n            width={width}\n            height={height}\n          />\n        </clipPath>\n        {noOfCells < 2 && gradFill && (\n          <linearGradient id={'levelGradient' + clipPathHash}>\n            {gradFill.map((item) => {\n              return (\n                <stop\n                  key={item.color}\n                  offset={item.offset + '%'}\n                  stopColor={item.color}\n                />\n              );\n            })}\n          </linearGradient>\n        )}\n      </defs>\n      {noOfCells === 1 && (\n        <g>\n          {gradFill ? (\n            <rect\n              className={BATTERY_METER}\n              clipPath={`url(#${CLIP_METER_FILLED + clipPathHash})`}\n              x={x}\n              y={y}\n              width={width}\n              height={height}\n              fill={`url(#levelGradient${clipPathHash})`}\n            />\n          ) : (\n            <rect\n              className={BATTERY_METER}\n              clipPath={`url(#${CLIP_METER + clipPathHash})`}\n              x={x}\n              y={y}\n              width={(width * value) / maxValue}\n              height={height}\n              fill={\n                checkLowBattery(value, lowBatteryValue) ? lowBatteryFill : fill\n              }\n            />\n          )}\n        </g>\n      )}\n      <g>\n        {noOfCells > 1 &&\n          cellList.map((_item, index) => {\n            return (\n              <rect\n                key={index}\n                className={BATTERY_METER}\n                clipPath={`url(#${CLIP_METER + clipPathHash})`}\n                x={x + ((width + interCellsGap) / noOfCells) * index}\n                y={y}\n                width={width / noOfCells - interCellsGap}\n                height={height}\n                fill={\n                  checkLowBattery(value, lowBatteryValue)\n                    ? lowBatteryFill\n                    : fill\n                }\n              />\n            );\n          })}\n      </g>\n    </g>\n  );\n};\n","import React from 'react';\nimport {\n  BATTERY_METER,\n  CLIP_METER,\n  CLIP_METER_EMPTY,\n  CLIP_METER_FILLED,\n  READING_TEXT,\n} from '../constants';\nimport { useGaugeContext } from '../hooks/useGaugeContext';\nimport { useLevelDimensions } from '../hooks/useLevelDimensions';\nimport {\n  checkLowBattery,\n  getValueInPercentage,\n  getVisibleCellsCount,\n} from '../utils';\nimport type { FormatValue } from '../../typings';\n\ntype ReadingTextProps = {\n  formatValue: FormatValue;\n};\nexport const ReadingText = (props: ReadingTextProps) => {\n  const { formatValue } = props;\n  const {\n    value,\n    maxValue,\n    orientation,\n    customization,\n    clipPathHash,\n  } = useGaugeContext();\n  const { x, y, width, height } = useLevelDimensions();\n  const {\n    fontFamily,\n    darkContrastColor,\n    lightContrastColor,\n    lowBatteryColor,\n    showPercentage,\n    fontSize,\n    ...otherTextProps\n  } = customization[READING_TEXT];\n  const { lowBatteryValue, noOfCells, interCellsGap } = customization[\n    BATTERY_METER\n  ];\n  const percentageSign = showPercentage ? '%' : '';\n  const valueRatio = value / maxValue;\n  const isCellTypeBattery = noOfCells > 1;\n  const noOfVisibleCells = getVisibleCellsCount(value, maxValue, noOfCells);\n  const noOfInvisibleCells = noOfCells - noOfVisibleCells;\n  const widthPerCell = width / noOfCells;\n  const readingValue = getValueInPercentage(value, maxValue);\n\n  const renderTextElement = (contrastColor: string, clipPathId: string) => {\n    return (\n      <text\n        className={READING_TEXT}\n        x={x + width / 2}\n        y={y + height / 2}\n        dominantBaseline=\"middle\"\n        textAnchor=\"middle\"\n        clipPath={`url(#${clipPathId})`}\n        fill={\n          checkLowBattery(value, lowBatteryValue)\n            ? lowBatteryColor\n            : contrastColor\n        }\n        fontFamily={fontFamily}\n        fontWeight=\"bold\"\n        fontSize={fontSize}\n        writingMode={orientation === 'vertical' ? 'tb' : 'lr'}\n        {...otherTextProps}\n      >\n        {formatValue(readingValue) + percentageSign}\n      </text>\n    );\n  };\n\n  return (\n    <g>\n      <defs>\n        <clipPath id={CLIP_METER_FILLED + clipPathHash}>\n          <rect\n            x={x}\n            y={y}\n            width={\n              isCellTypeBattery\n                ? widthPerCell * noOfVisibleCells - interCellsGap / 2\n                : width * valueRatio\n            }\n            height={height}\n            clipPath={`url(#${CLIP_METER + clipPathHash})`}\n          />\n        </clipPath>\n        <clipPath id={CLIP_METER_EMPTY + clipPathHash}>\n          <rect\n            x={\n              x +\n              (isCellTypeBattery\n                ? widthPerCell * noOfVisibleCells - interCellsGap / 2\n                : width * valueRatio)\n            }\n            y={y}\n            width={\n              isCellTypeBattery\n                ? widthPerCell * noOfInvisibleCells\n                : width * (1 - valueRatio)\n            }\n            height={height}\n            clipPath={`url(#${CLIP_METER + clipPathHash})`}\n          />\n        </clipPath>\n      </defs>\n      {renderTextElement(darkContrastColor, CLIP_METER_FILLED + clipPathHash)}\n      {renderTextElement(lightContrastColor, CLIP_METER_EMPTY + clipPathHash)}\n    </g>\n  );\n};\n","import { useEffect, useState, useCallback, useRef } from 'react';\nimport { timing } from '../utils';\n\nexport type AnimationType = {\n  value: number;\n  duration?: number;\n  startValue?: number;\n  enabled: boolean;\n  direction?: 'both' | 'reverse' | 'forward';\n  iterationCount?: number | 'infinite';\n  easing?: 'linear';\n};\n\nconst MAX_ANIMATION_PROGRESS = 1;\nconst MAX_LOOP_ANIMATION_PROGRESS = 2;\n\nexport const useCounterAnimation = ({\n  value,\n  duration = 1000,\n  startValue = 0,\n  enabled = false,\n  direction = 'forward',\n  iterationCount = 1,\n  easing = 'linear',\n}: AnimationType) => {\n  const [counterValue, setCounterValue] = useState(startValue);\n  const iteration = useRef(0);\n\n  const runAnimation = useCallback(() => {\n    iteration.current += 1;\n\n    return new Promise((resolve) => {\n      let startTime = 0;\n      const nextIterationDurationGap = duration / 5;\n      const step = (currentTime: number) => {\n        if (!startTime) {\n          startTime = currentTime;\n        }\n\n        //calculate the value to be used in calculating the number to be displayed\n        const progress = timing(\n          Math.min(\n            (currentTime - startTime) / duration,\n            direction === 'both'\n              ? MAX_LOOP_ANIMATION_PROGRESS\n              : MAX_ANIMATION_PROGRESS\n          ),\n          easing\n        );\n        function getNewValue(animationDir: AnimationType['direction']) {\n          if (animationDir === 'reverse') {\n            return (1 - progress) * (value - counterValue) + counterValue;\n          } else if (progress > 1 && animationDir === 'both') {\n            return (\n              (MAX_LOOP_ANIMATION_PROGRESS - progress) *\n                (value - counterValue) +\n              counterValue\n            );\n          } else {\n            return progress * (value - counterValue) + counterValue;\n          }\n        }\n        const newValue = getNewValue(direction);\n\n        //calculate what to be displayed using the value gotten above\n        setCounterValue(Math.floor(newValue));\n\n        if (\n          progress < MAX_ANIMATION_PROGRESS ||\n          (direction === 'both' && progress < MAX_LOOP_ANIMATION_PROGRESS)\n        ) {\n          window.requestAnimationFrame(step); //continue animation\n        } else {\n          window.cancelAnimationFrame(window.requestAnimationFrame(step));\n          resolve(true); //complete animation\n        }\n      };\n\n      // First loop of animation, take no delay\n      function runFirstIteration() {\n        window.requestAnimationFrame(step);\n      }\n\n      // For second loop for animation, take some pause before starting\n      function runNextIteration() {\n        setTimeout(() => {\n          window.requestAnimationFrame(step);\n        }, nextIterationDurationGap);\n      }\n      // start animation\n      (function startAnimation() {\n        iteration.current > 1 ? runNextIteration() : runFirstIteration();\n      })();\n    });\n  }, [value]);\n\n  useEffect(() => {\n    if (enabled) {\n      let animation = runAnimation();\n      const restartAnimation = () => {\n        animation.then(() => {\n          if (iterationCount === 'infinite') {\n            animation = runAnimation();\n            restartAnimation();\n            return;\n          }\n          if (iteration.current < iterationCount) {\n            animation = runAnimation();\n            restartAnimation();\n            return;\n          }\n        });\n      };\n      restartAnimation();\n    }\n  }, [enabled, iterationCount, value]);\n\n  return enabled ? counterValue : value;\n};\n","import React, { ReactElement } from 'react';\nimport { BATTERY_BODY, CHARGING_FLASH } from '../constants';\nimport { useCounterAnimation } from '../hooks/useCounterAnimation';\nimport { useGaugeContext } from '../hooks/useGaugeContext';\nimport { useLevelDimensions } from '../hooks/useLevelDimensions';\n\ninterface Props extends React.SVGProps<SVGPathElement> {\n  scale?: number;\n}\n// As per icon path\nconst iconWidth = 16.8; // As per path\nconst iconHeight = 28.7;\n\nexport default function Charging({ scale, ...pathProps }: Props): ReactElement {\n  const {\n    canvasWidth,\n    canvasHeight,\n    orientation,\n    customization,\n  } = useGaugeContext();\n  const { strokeWidth } = customization[BATTERY_BODY];\n  const { fill, animated, animationDuration  } = customization[CHARGING_FLASH];\n  const animatedOpacityPer = useCounterAnimation({\n    value: 100,\n    enabled: animated,\n    direction: 'both',\n    iterationCount: 'infinite',\n    duration: animationDuration,\n    startValue: 20,\n  });\n\n  const { width } = useLevelDimensions();\n  const iconXPos = width / 2 + iconWidth / 2;\n  const iconYPos = canvasHeight / 2 - iconHeight / 2;\n  const transformScale = scale ? `scale(${scale})` : '';\n  return (\n    <g\n      transform={\n        orientation === 'vertical'\n          ? `rotate(${-90})${transformScale}`\n          : transformScale\n      }\n      style={{\n        transformOrigin: `${canvasWidth / 2 - strokeWidth}px ${\n          canvasHeight / 2 - strokeWidth / 2\n        }px`,\n      }}\n      opacity={animatedOpacityPer / 100}\n    >\n      <path\n        d={`M${iconXPos},${iconYPos}l-13,16.8l7.4,0l-1.8,11.9l11.2,-16.8l-7.4,0l3.6,-11.9z`}\n        fill={fill}\n        {...pathProps}\n      />\n    </g>\n  );\n}\n","import React, { FC } from 'react';\nimport {\n  BATTERY_BODY,\n  BATTERY_CAP,\n  BATTERY_METER,\n  CANVAS_WIDTH,\n  CHARGING_FLASH,\n  READING_TEXT,\n} from './lib/constants';\nimport { Battery } from './lib/components/Battery';\nimport { Canvas } from './lib/Canvas';\nimport { BatteryLevel } from './lib/components/BatteryLevel';\nimport type {\n  DeepPartial,\n  FormatValue,\n  TGaugeCanvas,\n  TGaugeCustom,\n} from './typings';\nimport { defaultState } from './lib/store/context';\nimport { ReadingText } from './lib/components/ReadingText';\nimport { useCounterAnimation } from './lib/hooks/useCounterAnimation';\nimport { useClipPathHash } from './lib/hooks/useClipPathHash';\nimport Charging from './lib/components/Charging';\n\nexport interface Props\n  extends Omit<React.SVGProps<SVGSVGElement>, 'orientation'> {\n  /**\n   * Meter value range [0-100]\n   */\n  value: TGaugeCanvas['value'];\n  /**\n   * Meter max value\n   */\n  maxValue?: TGaugeCanvas['maxValue'];\n  /**\n   * Changes orientation, keeping text horizontal\n   */\n  orientation?: TGaugeCanvas['orientation'];\n\n  /**\n   * We don't like passing both width and height, can create unusual looking shape.\n   * Size will help gauge to achieve the desired size maintaining aspect ratio\n   */\n  size?: number;\n  /**\n   * Gauge aspect ratio,\n   * At padding 0 easy to create battery types ->\n   * D = 0.56,\n   * C = 0.52,\n   * AA = 0.28,\n   * AAA = 0.23,\n   * AAAA = 0.19 ,\n   * default C battery\n   */\n  aspectRatio?: number;\n  /**\n   * Padding of gauge within canvas\n   */\n  padding?: TGaugeCanvas['padding'];\n  /**\n   * Enable animation on mount\n   */\n  animated?: boolean;\n  /**\n   * Battery is charging\n   */\n  charging?: boolean;\n  /**\n   * Format the visible reading text as per your need\n   * Note: you can turn off percentage symbol from customizations\n   */\n  formatValue?: FormatValue;\n  /**\n   * All components customization\n   */\n  customization?: DeepPartial<TGaugeCustom>;\n}\n\nexport const BatteryGauge: FC<Props> = ({\n  size = 300,\n  aspectRatio = defaultState.aspectRatio,\n  children,\n  padding = defaultState.padding,\n  value = defaultState.value,\n  maxValue = defaultState.maxValue,\n  customization = defaultState.customization,\n  orientation = defaultState.orientation,\n  animated = defaultState.animated,\n  charging = defaultState.charging,\n  formatValue = (value) => value,\n  ...restSvgProps\n}) => {\n  const canvasHeight = Math.round(CANVAS_WIDTH * aspectRatio);\n  const height = Math.round(size * aspectRatio);\n  const clipPathHash = useClipPathHash();\n  const noLowBatteryColor = charging\n    ? {\n        lowBatteryFill:\n          customization[BATTERY_METER]?.fill ||\n          defaultState.customization[BATTERY_METER].fill,\n      }\n    : {};\n\n  const allCustomization: TGaugeCustom = {\n    [BATTERY_BODY]: {\n      ...defaultState.customization[BATTERY_BODY],\n      ...customization[BATTERY_BODY],\n    },\n    [BATTERY_CAP]: {\n      ...defaultState.customization[BATTERY_CAP],\n      ...customization[BATTERY_CAP],\n    },\n    [BATTERY_METER]: {\n      ...defaultState.customization[BATTERY_METER],\n      ...customization[BATTERY_METER],\n      ...noLowBatteryColor,\n    },\n    [READING_TEXT]: {\n      ...defaultState.customization[READING_TEXT],\n      ...customization[READING_TEXT],\n    },\n    [CHARGING_FLASH]: {\n      ...defaultState.customization[CHARGING_FLASH],\n      ...customization[CHARGING_FLASH],\n    },\n  };\n  const canvasPadding = allCustomization.batteryBody.strokeWidth / 2 + padding;\n  const newValue = useCounterAnimation({\n    value: value,\n    enabled: animated,\n  });\n  const chargingValue = useCounterAnimation({\n    startValue: 1,\n    value: maxValue,\n    enabled: charging,\n    iterationCount: 'infinite',\n    duration: 2000,\n  });\n  return (\n    <Canvas\n      width={size}\n      height={orientation === 'vertical' ? size : height}\n      canvasWidth={CANVAS_WIDTH}\n      canvasHeight={canvasHeight}\n      padding={canvasPadding}\n      value={charging ? chargingValue : newValue}\n      maxValue={!maxValue ? 1 : maxValue}\n      orientation={orientation}\n      customization={allCustomization}\n      clipPathHash={clipPathHash}\n      {...restSvgProps}\n    >\n      <g\n        transform={\n          orientation === 'vertical'\n            ? `rotate(-90,${CANVAS_WIDTH / 2},${canvasHeight / 2})` // rotate at right top corner\n            : ''\n        }\n      >\n        <Battery />\n        <BatteryLevel />\n        {charging ? <Charging /> : <ReadingText formatValue={formatValue} />}\n        {children}\n      </g>\n    </Canvas>\n  );\n};\n\nexport default BatteryGauge;\n","import { useEffect, useState } from 'react';\n\nexport function useClipPathHash() {\n  const [hash, setHash] = useState<string>('');\n  useEffect(() => {\n    setHash((Math.random() + 1).toString(36).substring(7));\n  }, []);\n  return hash;\n}\n"],"names":["CLIP_METER","defaultState","canvasWidth","canvasHeight","CANVAS_WIDTH","aspectRatio","CANVAS_HEIGHT","padding","value","maxValue","clipPathHash","orientation","animated","charging","customization","batteryBody","strokeWidth","cornerRadius","fill","strokeColor","batteryCap","capToBodyRatio","batteryMeter","lowBatteryValue","lowBatteryFill","outerGap","noOfCells","interCellsGap","readingText","lightContrastColor","darkContrastColor","lowBatteryColor","fontFamily","fontSize","showPercentage","chargingFlash","scale","undefined","animationDuration","Context","createContext","useGaugeContext","useContext","useBatteryDimensions","batteryCapRatio","capHeight","capWidth","bodyWidth","bodyHeight","Battery","bodyStrokeColor","bodyStrokeWidth","bodyFill","bodyCornerRadius","capStrokeColor","capStrokeWidth","capFill","capCornerRadius","React","id","x","y","width","height","className","rx","ry","stroke","clipPath","CanvasProvider","Provider","children","Canvas","props","otherSvgProps","viewBox","useLevelDimensions","useMemo","checkLowBattery","getVisibleCellsCount","Math","floor","abs","BatteryLevel","gradFill","cellList","noOfVisibleCells","Array","map","item","key","color","offset","stopColor","_item","index","ReadingText","formatValue","otherTextProps","percentageSign","valueRatio","isCellTypeBattery","noOfInvisibleCells","widthPerCell","readingValue","round","getValueInPercentage","renderTextElement","contrastColor","clipPathId","dominantBaseline","textAnchor","fontWeight","writingMode","useCounterAnimation","duration","startValue","enabled","direction","iterationCount","useState","counterValue","setCounterValue","iteration","useRef","runAnimation","useCallback","current","Promise","resolve","startTime","step","currentTime","animationDir","progress","easing","timing","min","newValue","window","requestAnimationFrame","cancelAnimationFrame","setTimeout","useEffect","animation","restartAnimation","then","Charging","pathProps","animatedOpacityPer","transformScale","transform","style","transformOrigin","opacity","d","iconWidth","iconHeight","BatteryGauge","hash","setHash","size","restSvgProps","random","toString","substring","noLowBatteryColor","allCustomization","canvasPadding","chargingValue"],"mappings":"ueAAO,IAWMA,EAAa,mBCPbC,EAAe,CAC1BC,YDL0B,ICM1BC,aAAcC,GACdC,YDJkCC,ICKlCC,QAAS,EACTC,MAAO,GACPC,SAAU,IACVC,aAAc,GACdC,YAAa,aACbC,UAAU,EACVC,UAAU,EACVC,cAAe,CACbC,YAAa,CACXC,YAAa,EACbC,aAAc,EACdC,KAAM,OACNC,YAAa,QAEfC,WAAY,CACVF,KAAM,OACNF,YAAa,EACbG,YAAa,OACbF,aAAc,EACdI,eAAgB,IAElBC,aAAc,CACZJ,KAAM,QACNK,gBAAiB,GACjBC,eAAgB,MAChBC,SAAU,EACVC,UAAW,EACXC,cAAe,GAEjBC,YAAa,CACXC,mBAAoB,OACpBC,kBAAmB,OACnBC,gBAAiB,MACjBC,WAAY,YACZC,SAAU,GACVC,gBAAgB,GAElBC,cAAe,CACbC,WAAOC,EACPnB,KAAM,SACNN,UAAU,EACV0B,kBAAmB,OAKZC,EAAUC,gBAA4BvC,YCnDnCwC,WACPC,aAAWH,GCFb,IAAMI,EAAuB,SAACC,SACYH,IAAvCtC,IAAAA,aAA2BI,IAAAA,QAE7BsC,GADe1C,EAAe,EAAII,GACPqC,EAC3BE,EAAWD,EAAY,QAEtB,CACLE,YANoB7C,YAMK4C,EAAW,EAAIvC,EACxCyC,WAAY7C,EAAe,EAAII,EAC/BuC,SAAAA,EACAD,UAAAA,ICPSI,EAAU,iBAOjBR,IALFvC,IAAAA,YACAC,IAAAA,aACAI,IAAAA,QACAO,IAAAA,cACAJ,IAAAA,eAQEI,EAAa,YAJFoC,IAAb/B,YACagC,IAAbnC,YACMoC,IAANlC,KACcmC,IAAdpC,eASEH,EAAa,WALFwC,IAAbnC,YACaoC,IAAbvC,YACMwC,IAANtC,KACcuC,IAAdxC,eAIqD0B,IAHrDtB,gBAGM0B,IAAAA,UAAWC,IAAAA,WAAYF,IAAAA,SAAUD,IAAAA,iBAIvCa,yBACEA,4BACEA,4BAAUC,GJrBM,mBIqBSjD,GACvBgD,wBACEE,EAAG1D,EAAcK,EAAUuC,EAC3Be,GAAI1D,EAAe0C,EAAYU,GAAkB,EACjDO,MAAOhB,EACPiB,OAAQlB,EAAYU,EACpBvC,YAAauC,MAInBG,wBACEM,UJ1CoB,cI2CpBJ,EAAGrD,EACHsD,EAAGtD,EACH0D,GAAIZ,EACJa,GAAIb,EACJS,MAAOf,EACPgB,OAAQf,EACRhC,YAAamC,EACbjC,KAAMkC,EACNe,OAAQjB,IAEVQ,wBACEU,iCAA6B1D,MAC7BsD,UJtDmB,aIuDnBJ,EAAG1D,EAAcK,EAAUuC,EAAWW,EACtCI,GAAI1D,EAAe0C,GAAa,EAChCoB,GAAIR,EACJS,GAAIT,EACJK,MAAOhB,EACPiB,OAAQlB,EACR7B,YAAauC,EACbrC,KAAMsC,EACNW,OAAQb,MC5DHe,EAA4B,mBAChCX,gBAACnB,EAAQ+B,UAAS9D,QAD2BA,SAAV+D,iICA/BC,EAAS,SAACC,OAEnBF,EAUEE,EAVFF,SACArE,EASEuE,EATFvE,YACAC,EAQEsE,EARFtE,aACAI,EAOEkE,EAPFlE,QACAC,EAMEiE,EANFjE,MACAC,EAKEgE,EALFhE,SACAE,EAIE8D,EAJF9D,YACAG,EAGE2D,EAHF3D,cACAJ,EAEE+D,EAFF/D,aACGgE,IACDD,YAEFf,gBAACW,GACC7D,MAAO,CACLN,YAAAA,EACAC,aAAAA,EACAI,QAAAA,EACAC,MAAAA,EACAC,SAAAA,EACAE,YAAAA,EACAG,cAAAA,EACAJ,aAAAA,IAGFgD,qCAAKiB,eAAgBzE,MAAeC,GAAoBuE,GACrDH,KC9BIK,EAAqB,iBACGnC,IAA3BlC,IAAAA,QAASO,IAAAA,cACTE,EAAgBF,EAAa,YAA7BE,YAEAS,EAAaX,EAAa,aAA1BW,WAC0BkB,EAFP7B,EAAa,WAAhCO,gBAEA0B,IAAAA,UAAWC,IAAAA,kBAEZ6B,WAAQ,iBAGN,CACLjB,EAAGrD,EAAUS,EAAc,EAAIS,EAC/BoC,EAAGtD,EAAUS,EAAc,EAAIS,EAC/BqC,MALqBf,EAAY/B,EAKT,EAAIS,EAC5BsC,OALsBf,EAAahC,EAKT,EAAIS,KAE/B,CAACsB,EAAWC,EAAYvB,EAAUlB,EAASS,cCjBhC8D,EAAgBtE,EAAee,UACtCf,EAAQe,EAGjB,SAAgBwD,EACdvE,EACAC,EACAiB,UAEOsD,KAAKC,MAAMD,KAAKE,IAAI1E,EAAQC,GAAYiB,GAEjD,ICJayD,EAAe,iBAC+B1C,IAAjDjC,IAAAA,MAAOC,IAAAA,SAAUK,IAAAA,cAAeJ,IAAAA,eACRkE,IAAxBhB,IAAAA,EAAGC,IAAAA,EAAGC,IAAAA,MAAOC,IAAAA,SASjBjD,EAAa,aAPfI,IAAAA,KACAM,IAAAA,eACA4D,IAAAA,SACA7D,IAAAA,gBACAE,IAAAA,SACAC,IAAAA,UACAC,IAAAA,gBAKEb,EAAa,YAFFqC,IAAbnC,YACcqC,IAAdpC,aAGIoE,EAAWR,WAAQ,eACjBS,EAAmBP,EAAqBvE,EAAOC,EAAUiB,UACtC,IAArB4D,GAA0B9E,EAAQ,EAC7B,CAAC,QAEH,IAAI+E,MAAMD,GAAkBpE,KAAK,UACvC,CAACV,EAAOC,EAAUiB,WAGnBgC,yBACEA,4BACEA,4BAAUC,GAAI3D,EAAaU,GACzBgD,wBACEE,EAAGA,EACHC,EAAGA,EACHI,GAAIZ,EAAmBF,EAAkB,EAAI1B,EAC7CyC,GAAIb,EAAmBF,EAAkB,EAAI1B,EAC7CqC,MAAOA,EACPC,OAAQA,KAGXrC,EAAY,GAAK0D,GAChB1B,kCAAgBC,GAAI,gBAAkBjD,GACnC0E,EAASI,KAAI,SAACC,UAEX/B,wBACEgC,IAAKD,EAAKE,MACVC,OAAQH,EAAKG,OAAS,IACtBC,UAAWJ,EAAKE,aAOb,IAAdjE,GACCgC,yBAEIA,uBADD0B,GAEGpB,UT7De,eS8DfI,wCAAsC1D,MACtCkD,EAAGA,EACHC,EAAGA,EACHC,MAAOA,EACPC,OAAQA,EACR7C,0BAA2BR,QAI3BsD,UTvEe,eSwEfI,kBAAkBpE,EAAaU,OAC/BkD,EAAGA,EACHC,EAAGA,EACHC,MAAQA,EAAQtD,EAASC,EACzBsD,OAAQA,EACR7C,KACE4D,EAAgBtE,EAAOe,GAAmBC,EAAiBN,KAMrEwC,yBACGhC,EAAY,GACX2D,EAASG,KAAI,SAACM,EAAOC,UAEjBrC,wBACEgC,IAAKK,EACL/B,UT1Fa,eS2FbI,kBAAkBpE,EAAaU,OAC/BkD,EAAGA,GAAME,EAAQnC,GAAiBD,EAAaqE,EAC/ClC,EAAGA,EACHC,MAAOA,EAAQpC,EAAYC,EAC3BoC,OAAQA,EACR7C,KACE4D,EAAgBtE,EAAOe,GACnBC,EACAN,kHCrFT8E,EAAc,SAACvB,OAClBwB,EAAgBxB,EAAhBwB,cAOJxD,IALFjC,IAAAA,MACAC,IAAAA,SACAE,IAAAA,YACAG,IAAAA,cACAJ,IAAAA,eAE8BkE,IAAxBhB,IAAAA,EAAGC,IAAAA,EAAGC,IAAAA,MAAOC,IAAAA,SASjBjD,EAAa,YAPfkB,IAAAA,WACAF,IAAAA,kBACAD,IAAAA,mBACAE,IAAAA,gBACAG,IAAAA,eACAD,IAAAA,SACGiE,WAEiDpF,EAAa,aAA3DS,IAAAA,gBAAiBG,IAAAA,UAAWC,IAAAA,cAG9BwE,EAAiBjE,EAAiB,IAAM,GACxCkE,EAAa5F,EAAQC,EACrB4F,EAAoB3E,EAAY,EAChC4D,EAAmBP,EAAqBvE,EAAOC,EAAUiB,GACzD4E,EAAqB5E,EAAY4D,EACjCiB,EAAezC,EAAQpC,EACvB8E,WFhD6BhG,EAAeC,UAC3CuE,KAAKyB,MAAOjG,EAAQC,EAAY,KE+ClBiG,CAAqBlG,EAAOC,GAE3CkG,EAAoB,SAACC,EAAuBC,UAE9CnD,sCACEM,UV9CoB,cU+CpBJ,EAAGA,EAAIE,EAAQ,EACfD,EAAGA,EAAIE,EAAS,EAChB+C,iBAAiB,SACjBC,WAAW,SACX3C,iBAAkByC,MAClB3F,KACE4D,EAAgBtE,EAAOe,GACnBQ,EACA6E,EAEN5E,WAAYA,EACZgF,WAAW,OACX/E,SAAUA,EACVgF,YAA6B,aAAhBtG,EAA6B,KAAO,MAC7CuF,GAEHD,EAAYO,GAAgBL,WAMjCzC,yBACEA,4BACEA,4BAAUC,GVlEe,0BUkESjD,GAChCgD,wBACEE,EAAGA,EACHC,EAAGA,EACHC,MACEuC,EACIE,EAAejB,EAAmB3D,EAAgB,EAClDmC,EAAQsC,EAEdrC,OAAQA,EACRK,kBAAkBpE,EAAaU,UAGnCgD,4BAAUC,GV9Ec,yBU8ESjD,GAC/BgD,wBACEE,EACEA,GACCyC,EACGE,EAAejB,EAAmB3D,EAAgB,EAClDmC,EAAQsC,GAEdvC,EAAGA,EACHC,MACEuC,EACIE,EAAeD,EACfxC,GAAS,EAAIsC,GAEnBrC,OAAQA,EACRK,kBAAkBpE,EAAaU,WAIpCiG,EAAkB7E,EVlGQ,0BUkG+BpB,GACzDiG,EAAkB9E,EVlGO,yBUkGgCnB,KC/FnDwG,EAAsB,gBACjC1G,IAAAA,UACA2G,SAAAA,aAAW,UACXC,eACAC,QAAAA,oBACAC,UAAAA,aAAY,gBACZC,eAAAA,aAAiB,MAGuBC,sBAN3B,KAMNC,OAAcC,OACfC,EAAYC,SAAO,GAEnBC,EAAeC,eAAY,kBAC/BH,EAAUI,SAAW,EAEd,IAAIC,SAAQ,SAACC,OACdC,EAAY,EAEVC,EAAO,SAAPA,EAAQC,GACPF,IACHA,EAAYE,OAaOC,EATfC,EHzBQ,SAACA,EAAkBC,UAE9BD,EGuBcE,CACfxD,KAAKyD,KACFL,EAAcF,GAAaf,EACd,SAAdG,EA7BwB,EADL,IAiDjBoB,EAZiB,aADFL,EAaQf,IAXjB,EAAIgB,IAAa9H,EAAQiH,GAAgBA,EACxCa,EAAW,GAAsB,SAAjBD,GAtCD,EAwCSC,IAC5B9H,EAAQiH,GACXA,EAGKa,GAAY9H,EAAQiH,GAAgBA,EAM/CC,EAAgB1C,KAAKC,MAAMyD,IAGzBJ,EAvDqB,GAwDN,SAAdhB,GAAwBgB,EAvDC,EAyD1BK,OAAOC,sBAAsBT,IAE7BQ,OAAOE,qBAAqBF,OAAOC,sBAAsBT,IACzDF,GAAQ,KAiBVN,EAAUI,QAAU,EANpBe,YAAW,WACTH,OAAOC,sBAAsBT,KArDAhB,EAAW,GA+C1CwB,OAAOC,sBAAsBT,QAchC,CAAC3H,WAEJuI,aAAU,cACJ1B,EAAS,KACP2B,EAAYnB,KACS,SAAnBoB,IACJD,EAAUE,MAAK,iBACU,aAAnB3B,GAKAI,EAAUI,QAAUR,GAJtByB,EAAYnB,SACZoB,eAUNA,MAED,CAAC5B,EAASE,EAAgB/G,IAEtB6G,EAAUI,EAAejH,wBCxGV2I,SAAW/G,IAAAA,MAAUgH,WAMvC3G,IAJFvC,IAAAA,YACAC,IAAAA,aACAQ,IAAAA,YACAG,IAAAA,cAEME,EAAgBF,EAAa,YAA7BE,cACuCF,EAAa,cAApDI,IAAAA,KACFmI,EAAqBnC,EAAoB,CAC7C1G,MAAO,IACP6G,UAHYzG,SAIZ0G,UAAW,OACXC,eAAgB,WAChBJ,WANsB7E,kBAOtB8E,WAAY,OAGIxC,IAGZ0E,EAAiBlH,WAAiBA,MAAW,UAEjDsB,qBACE6F,UACkB,aAAhB5I,gBACqB2I,EACjBA,EAENE,MAAO,CACLC,gBAAoBvJ,EAAc,EAAIc,SACpCb,EAAe,EAAIa,EAAc,SAGrC0I,QAASL,EAAqB,KAE9B3F,sCACEiG,SAnBE7F,MACiB,EAAI8F,UACZzJ,EAAe,EAAI0J,gEAkB9B3I,KAAMA,GACFkI,4IC0BCU,EAA0B,sBC3E9BC,EAAMC,MD4EbC,KAAAA,aAAO,UACP5J,YAAAA,aAAcJ,EAAaI,cAC3BkE,IAAAA,aACAhE,QAAAA,aAAUN,EAAaM,cACvBC,MAAAA,aAAQP,EAAaO,YACrBC,SAAAA,aAAWR,EAAaQ,eACxBK,cAAAA,aAAgBb,EAAaa,oBAC7BH,YAAAA,aAAcV,EAAaU,kBAC3BC,SAAAA,aAAWX,EAAaW,eACxBC,SAAAA,aAAWZ,EAAaY,eACxBoF,YAAAA,aAAc,SAACzF,UAAUA,KACtB0J,SAEG/J,EAAe6E,KAAKyB,Mb5FA,Ia4FqBpG,GACzC0D,EAASiB,KAAKyB,MAAMwD,EAAO5J,GAC3BK,GC3FCqJ,KAAiBvC,WAAiB,QAA5BwC,OACbjB,aAAU,WACRiB,GAAShF,KAAKmF,SAAW,GAAGC,SAAS,IAAIC,UAAU,MAClD,IACIN,GDwFDO,EAAoBzJ,EACtB,CACEW,yBACEV,EAAa,uBAAiBI,OAC9BjB,EAAaa,cAAb,aAA0CI,MAE9C,GAEEqJ,UAAgB,iBAEftK,EAAaa,cAAb,YACAA,EAAa,eAHE,gBAMfb,EAAaa,cAAb,WACAA,EAAa,cAPE,kBAUfb,EAAaa,cAAb,aACAA,EAAa,aACbwJ,KAZe,iBAefrK,EAAaa,cAAb,YACAA,EAAa,eAhBE,mBAmBfb,EAAaa,cAAb,cACAA,EAAa,kBAGd0J,EAAgBD,EAAiBxJ,YAAYC,YAAc,EAAIT,EAC/DmI,EAAWxB,EAAoB,CACnC1G,MAAOA,EACP6G,QAASzG,IAEL6J,EAAgBvD,EAAoB,CACxCE,WAAY,EACZ5G,MAAOC,EACP4G,QAASxG,EACT0G,eAAgB,WAChBJ,SAAU,aAGVzD,gBAACc,iBACCV,MAAOmG,EACPlG,OAAwB,aAAhBpD,EAA6BsJ,EAAOlG,EAC5C7D,Yb9IsB,Ia+ItBC,aAAcA,EACdI,QAASiK,EACThK,MAAOK,EAAW4J,EAAgB/B,EAClCjI,SAAWA,GAAW,EACtBE,YAAaA,EACbG,cAAeyJ,EACf7J,aAAcA,GACVwJ,GAEJxG,qBACE6F,UACkB,aAAhB5I,mBACsCR,EAAe,MACjD,IAGNuD,gBAACT,QACDS,gBAACyB,QACAtE,EAAW6C,gBAACyF,QAAczF,gBAACsC,GAAYC,YAAaA,IACpD1B"}