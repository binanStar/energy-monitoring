import React, { createContext, useContext, useMemo, useState, useRef, useCallback, useEffect } from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var CANVAS_WIDTH = 100;
var CANVAS_HEIGHT = 52;
var BATTERY_ASPECT_RATIO = CANVAS_HEIGHT / CANVAS_WIDTH; // battery is horizontal

var BATTERY_BODY = 'batteryBody';
var BATTERY_CAP = 'batteryCap';
var BATTERY_METER = 'batteryMeter';
var READING_TEXT = 'readingText';
var CHARGING_FLASH = 'chargingFlash'; // clipPath ids

var CLIP_METER = 'clip_level_meter';
var CLIP_METER_FILLED = 'clip_level_meter_filled';
var CLIP_METER_EMPTY = 'clip_level_meter_empty';
var CLIP_CAP = 'battery_cap_clip';

var defaultState = {
  canvasWidth: CANVAS_WIDTH,
  canvasHeight: CANVAS_WIDTH * BATTERY_ASPECT_RATIO,
  aspectRatio: BATTERY_ASPECT_RATIO,
  padding: 0,
  value: 50,
  maxValue: 100,
  clipPathHash: '',
  orientation: 'horizontal',
  animated: false,
  charging: false,
  customization: {
    batteryBody: {
      strokeWidth: 4,
      cornerRadius: 6,
      fill: 'none',
      strokeColor: '#111'
    },
    batteryCap: {
      fill: 'none',
      strokeWidth: 4,
      strokeColor: '#111',
      cornerRadius: 2,
      capToBodyRatio: 0.4
    },
    batteryMeter: {
      fill: 'green',
      lowBatteryValue: 15,
      lowBatteryFill: 'red',
      outerGap: 1,
      noOfCells: 1,
      interCellsGap: 1
    },
    readingText: {
      lightContrastColor: '#111',
      darkContrastColor: '#fff',
      lowBatteryColor: 'red',
      fontFamily: 'Helvetica',
      fontSize: 14,
      showPercentage: true
    },
    chargingFlash: {
      scale: undefined,
      fill: 'orange',
      animated: true,
      animationDuration: 1000
    }
  }
};
var Context = /*#__PURE__*/createContext(defaultState);

function useGaugeContext() {
  return useContext(Context);
}

var useBatteryDimensions = function useBatteryDimensions(batteryCapRatio) {
  var _useGaugeContext = useGaugeContext(),
      canvasHeight = _useGaugeContext.canvasHeight,
      canvasWidth = _useGaugeContext.canvasWidth,
      padding = _useGaugeContext.padding;

  var objectHeight = canvasHeight - 2 * padding; // total canvas height minus vertical padding

  var capHeight = objectHeight * batteryCapRatio;
  var capWidth = capHeight / 2;
  return {
    bodyWidth: canvasWidth - capWidth - 2 * padding,
    bodyHeight: canvasHeight - 2 * padding,
    capWidth: capWidth,
    capHeight: capHeight
  };
};

var Battery = function Battery() {
  var _useGaugeContext = useGaugeContext(),
      canvasWidth = _useGaugeContext.canvasWidth,
      canvasHeight = _useGaugeContext.canvasHeight,
      padding = _useGaugeContext.padding,
      customization = _useGaugeContext.customization,
      clipPathHash = _useGaugeContext.clipPathHash;

  var _customization$BATTER = customization[BATTERY_BODY],
      bodyStrokeColor = _customization$BATTER.strokeColor,
      bodyStrokeWidth = _customization$BATTER.strokeWidth,
      bodyFill = _customization$BATTER.fill,
      bodyCornerRadius = _customization$BATTER.cornerRadius;
  var _customization$BATTER2 = customization[BATTERY_CAP],
      capStrokeColor = _customization$BATTER2.strokeColor,
      capStrokeWidth = _customization$BATTER2.strokeWidth,
      capFill = _customization$BATTER2.fill,
      capCornerRadius = _customization$BATTER2.cornerRadius,
      capToBodyRatio = _customization$BATTER2.capToBodyRatio;

  var _useBatteryDimensions = useBatteryDimensions(capToBodyRatio),
      bodyWidth = _useBatteryDimensions.bodyWidth,
      bodyHeight = _useBatteryDimensions.bodyHeight,
      capWidth = _useBatteryDimensions.capWidth,
      capHeight = _useBatteryDimensions.capHeight;

  return React.createElement("g", null, React.createElement("defs", null, React.createElement("clipPath", {
    id: CLIP_CAP + clipPathHash
  }, React.createElement("rect", {
    x: canvasWidth - padding - capWidth,
    y: (canvasHeight - capHeight - capStrokeWidth) / 2,
    width: capWidth,
    height: capHeight + capStrokeWidth,
    strokeWidth: capStrokeWidth
  }))), React.createElement("rect", {
    className: BATTERY_BODY,
    x: padding,
    y: padding,
    rx: bodyCornerRadius,
    ry: bodyCornerRadius,
    width: bodyWidth,
    height: bodyHeight,
    strokeWidth: bodyStrokeWidth,
    fill: bodyFill,
    stroke: bodyStrokeColor
  }), React.createElement("rect", {
    clipPath: "url(#" + (CLIP_CAP + clipPathHash) + ")",
    className: BATTERY_CAP,
    x: canvasWidth - padding - capWidth - capCornerRadius,
    y: (canvasHeight - capHeight) / 2,
    rx: capCornerRadius,
    ry: capCornerRadius,
    width: capWidth,
    height: capHeight,
    strokeWidth: capStrokeWidth,
    fill: capFill,
    stroke: capStrokeColor
  }));
};

var CanvasProvider = function CanvasProvider(_ref) {
  var children = _ref.children,
      value = _ref.value;
  return React.createElement(Context.Provider, {
    value: value
  }, children);
};

var _excluded = ["children", "canvasWidth", "canvasHeight", "padding", "value", "maxValue", "orientation", "customization", "clipPathHash"];
var Canvas = function Canvas(props) {
  var children = props.children,
      canvasWidth = props.canvasWidth,
      canvasHeight = props.canvasHeight,
      padding = props.padding,
      value = props.value,
      maxValue = props.maxValue,
      orientation = props.orientation,
      customization = props.customization,
      clipPathHash = props.clipPathHash,
      otherSvgProps = _objectWithoutPropertiesLoose(props, _excluded);

  return React.createElement(CanvasProvider, {
    value: {
      canvasWidth: canvasWidth,
      canvasHeight: canvasHeight,
      padding: padding,
      value: value,
      maxValue: maxValue,
      orientation: orientation,
      customization: customization,
      clipPathHash: clipPathHash
    }
  }, React.createElement("svg", Object.assign({
    viewBox: "0 0 " + canvasWidth + " " + canvasHeight
  }, otherSvgProps), children));
};

var useLevelDimensions = function useLevelDimensions() {
  var _useGaugeContext = useGaugeContext(),
      padding = _useGaugeContext.padding,
      customization = _useGaugeContext.customization;

  var strokeWidth = customization[BATTERY_BODY].strokeWidth;
  var capToBodyRatio = customization[BATTERY_CAP].capToBodyRatio;
  var outerGap = customization[BATTERY_METER].outerGap;

  var _useBatteryDimensions = useBatteryDimensions(capToBodyRatio),
      bodyWidth = _useBatteryDimensions.bodyWidth,
      bodyHeight = _useBatteryDimensions.bodyHeight;

  return useMemo(function () {
    var innerBodyWidth = bodyWidth - strokeWidth;
    var innerBodyHeight = bodyHeight - strokeWidth;
    return {
      x: padding + strokeWidth / 2 + outerGap,
      y: padding + strokeWidth / 2 + outerGap,
      width: innerBodyWidth - 2 * outerGap,
      height: innerBodyHeight - 2 * outerGap
    };
  }, [bodyWidth, bodyHeight, outerGap, padding, strokeWidth]);
};

function getValueInPercentage(value, maxValue) {
  return Math.round(value / maxValue * 100);
}
function checkLowBattery(value, lowBatteryValue) {
  return value < lowBatteryValue;
}
function getVisibleCellsCount(value, maxValue, noOfCells) {
  return Math.floor(Math.abs(value / maxValue) * noOfCells);
}
var timing = function timing(progress, easing) {
  if (easing === 'linear') {
    return progress;
  }

  return progress;
};

var BatteryLevel = function BatteryLevel() {
  var _useGaugeContext = useGaugeContext(),
      value = _useGaugeContext.value,
      maxValue = _useGaugeContext.maxValue,
      customization = _useGaugeContext.customization,
      clipPathHash = _useGaugeContext.clipPathHash;

  var _useLevelDimensions = useLevelDimensions(),
      x = _useLevelDimensions.x,
      y = _useLevelDimensions.y,
      width = _useLevelDimensions.width,
      height = _useLevelDimensions.height;

  var _customization$BATTER = customization[BATTERY_METER],
      fill = _customization$BATTER.fill,
      lowBatteryFill = _customization$BATTER.lowBatteryFill,
      gradFill = _customization$BATTER.gradFill,
      lowBatteryValue = _customization$BATTER.lowBatteryValue,
      outerGap = _customization$BATTER.outerGap,
      noOfCells = _customization$BATTER.noOfCells,
      interCellsGap = _customization$BATTER.interCellsGap;
  var _customization$BATTER2 = customization[BATTERY_BODY],
      bodyStrokeWidth = _customization$BATTER2.strokeWidth,
      bodyCornerRadius = _customization$BATTER2.cornerRadius;
  var cellList = useMemo(function () {
    var noOfVisibleCells = getVisibleCellsCount(value, maxValue, noOfCells);

    if (noOfVisibleCells === 0 && value > 0) {
      return ['cell'];
    }

    return new Array(noOfVisibleCells).fill('cell');
  }, [value, maxValue, noOfCells]);
  return React.createElement("g", null, React.createElement("defs", null, React.createElement("clipPath", {
    id: CLIP_METER + clipPathHash
  }, React.createElement("rect", {
    x: x,
    y: y,
    rx: bodyCornerRadius - bodyStrokeWidth / 2 - outerGap,
    ry: bodyCornerRadius - bodyStrokeWidth / 2 - outerGap,
    width: width,
    height: height
  })), noOfCells < 2 && gradFill && React.createElement("linearGradient", {
    id: 'levelGradient' + clipPathHash
  }, gradFill.map(function (item) {
    return React.createElement("stop", {
      key: item.color,
      offset: item.offset + '%',
      stopColor: item.color
    });
  }))), noOfCells === 1 && React.createElement("g", null, gradFill ? React.createElement("rect", {
    className: BATTERY_METER,
    clipPath: "url(#" + (CLIP_METER_FILLED + clipPathHash) + ")",
    x: x,
    y: y,
    width: width,
    height: height,
    fill: "url(#levelGradient" + clipPathHash + ")"
  }) : React.createElement("rect", {
    className: BATTERY_METER,
    clipPath: "url(#" + (CLIP_METER + clipPathHash) + ")",
    x: x,
    y: y,
    width: width * value / maxValue,
    height: height,
    fill: checkLowBattery(value, lowBatteryValue) ? lowBatteryFill : fill
  })), React.createElement("g", null, noOfCells > 1 && cellList.map(function (_item, index) {
    return React.createElement("rect", {
      key: index,
      className: BATTERY_METER,
      clipPath: "url(#" + (CLIP_METER + clipPathHash) + ")",
      x: x + (width + interCellsGap) / noOfCells * index,
      y: y,
      width: width / noOfCells - interCellsGap,
      height: height,
      fill: checkLowBattery(value, lowBatteryValue) ? lowBatteryFill : fill
    });
  })));
};

var _excluded$1 = ["fontFamily", "darkContrastColor", "lightContrastColor", "lowBatteryColor", "showPercentage", "fontSize"];
var ReadingText = function ReadingText(props) {
  var formatValue = props.formatValue;

  var _useGaugeContext = useGaugeContext(),
      value = _useGaugeContext.value,
      maxValue = _useGaugeContext.maxValue,
      orientation = _useGaugeContext.orientation,
      customization = _useGaugeContext.customization,
      clipPathHash = _useGaugeContext.clipPathHash;

  var _useLevelDimensions = useLevelDimensions(),
      x = _useLevelDimensions.x,
      y = _useLevelDimensions.y,
      width = _useLevelDimensions.width,
      height = _useLevelDimensions.height;

  var _customization$READIN = customization[READING_TEXT],
      fontFamily = _customization$READIN.fontFamily,
      darkContrastColor = _customization$READIN.darkContrastColor,
      lightContrastColor = _customization$READIN.lightContrastColor,
      lowBatteryColor = _customization$READIN.lowBatteryColor,
      showPercentage = _customization$READIN.showPercentage,
      fontSize = _customization$READIN.fontSize,
      otherTextProps = _objectWithoutPropertiesLoose(_customization$READIN, _excluded$1);

  var _customization$BATTER = customization[BATTERY_METER],
      lowBatteryValue = _customization$BATTER.lowBatteryValue,
      noOfCells = _customization$BATTER.noOfCells,
      interCellsGap = _customization$BATTER.interCellsGap;
  var percentageSign = showPercentage ? '%' : '';
  var valueRatio = value / maxValue;
  var isCellTypeBattery = noOfCells > 1;
  var noOfVisibleCells = getVisibleCellsCount(value, maxValue, noOfCells);
  var noOfInvisibleCells = noOfCells - noOfVisibleCells;
  var widthPerCell = width / noOfCells;
  var readingValue = getValueInPercentage(value, maxValue);

  var renderTextElement = function renderTextElement(contrastColor, clipPathId) {
    return React.createElement("text", Object.assign({
      className: READING_TEXT,
      x: x + width / 2,
      y: y + height / 2,
      dominantBaseline: "middle",
      textAnchor: "middle",
      clipPath: "url(#" + clipPathId + ")",
      fill: checkLowBattery(value, lowBatteryValue) ? lowBatteryColor : contrastColor,
      fontFamily: fontFamily,
      fontWeight: "bold",
      fontSize: fontSize,
      writingMode: orientation === 'vertical' ? 'tb' : 'lr'
    }, otherTextProps), formatValue(readingValue) + percentageSign);
  };

  return React.createElement("g", null, React.createElement("defs", null, React.createElement("clipPath", {
    id: CLIP_METER_FILLED + clipPathHash
  }, React.createElement("rect", {
    x: x,
    y: y,
    width: isCellTypeBattery ? widthPerCell * noOfVisibleCells - interCellsGap / 2 : width * valueRatio,
    height: height,
    clipPath: "url(#" + (CLIP_METER + clipPathHash) + ")"
  })), React.createElement("clipPath", {
    id: CLIP_METER_EMPTY + clipPathHash
  }, React.createElement("rect", {
    x: x + (isCellTypeBattery ? widthPerCell * noOfVisibleCells - interCellsGap / 2 : width * valueRatio),
    y: y,
    width: isCellTypeBattery ? widthPerCell * noOfInvisibleCells : width * (1 - valueRatio),
    height: height,
    clipPath: "url(#" + (CLIP_METER + clipPathHash) + ")"
  }))), renderTextElement(darkContrastColor, CLIP_METER_FILLED + clipPathHash), renderTextElement(lightContrastColor, CLIP_METER_EMPTY + clipPathHash));
};

var MAX_ANIMATION_PROGRESS = 1;
var MAX_LOOP_ANIMATION_PROGRESS = 2;
var useCounterAnimation = function useCounterAnimation(_ref) {
  var value = _ref.value,
      _ref$duration = _ref.duration,
      duration = _ref$duration === void 0 ? 1000 : _ref$duration,
      _ref$startValue = _ref.startValue,
      startValue = _ref$startValue === void 0 ? 0 : _ref$startValue,
      _ref$enabled = _ref.enabled,
      enabled = _ref$enabled === void 0 ? false : _ref$enabled,
      _ref$direction = _ref.direction,
      direction = _ref$direction === void 0 ? 'forward' : _ref$direction,
      _ref$iterationCount = _ref.iterationCount,
      iterationCount = _ref$iterationCount === void 0 ? 1 : _ref$iterationCount,
      _ref$easing = _ref.easing,
      easing = _ref$easing === void 0 ? 'linear' : _ref$easing;

  var _useState = useState(startValue),
      counterValue = _useState[0],
      setCounterValue = _useState[1];

  var iteration = useRef(0);
  var runAnimation = useCallback(function () {
    iteration.current += 1;
    return new Promise(function (resolve) {
      var startTime = 0;
      var nextIterationDurationGap = duration / 5;

      var step = function step(currentTime) {
        if (!startTime) {
          startTime = currentTime;
        } //calculate the value to be used in calculating the number to be displayed


        var progress = timing(Math.min((currentTime - startTime) / duration, direction === 'both' ? MAX_LOOP_ANIMATION_PROGRESS : MAX_ANIMATION_PROGRESS), easing);

        function getNewValue(animationDir) {
          if (animationDir === 'reverse') {
            return (1 - progress) * (value - counterValue) + counterValue;
          } else if (progress > 1 && animationDir === 'both') {
            return (MAX_LOOP_ANIMATION_PROGRESS - progress) * (value - counterValue) + counterValue;
          } else {
            return progress * (value - counterValue) + counterValue;
          }
        }

        var newValue = getNewValue(direction); //calculate what to be displayed using the value gotten above

        setCounterValue(Math.floor(newValue));

        if (progress < MAX_ANIMATION_PROGRESS || direction === 'both' && progress < MAX_LOOP_ANIMATION_PROGRESS) {
          window.requestAnimationFrame(step); //continue animation
        } else {
          window.cancelAnimationFrame(window.requestAnimationFrame(step));
          resolve(true); //complete animation
        }
      }; // First loop of animation, take no delay


      function runFirstIteration() {
        window.requestAnimationFrame(step);
      } // For second loop for animation, take some pause before starting


      function runNextIteration() {
        setTimeout(function () {
          window.requestAnimationFrame(step);
        }, nextIterationDurationGap);
      } // start animation


      (function startAnimation() {
        iteration.current > 1 ? runNextIteration() : runFirstIteration();
      })();
    });
  }, [value]);
  useEffect(function () {
    if (enabled) {
      var animation = runAnimation();

      var restartAnimation = function restartAnimation() {
        animation.then(function () {
          if (iterationCount === 'infinite') {
            animation = runAnimation();
            restartAnimation();
            return;
          }

          if (iteration.current < iterationCount) {
            animation = runAnimation();
            restartAnimation();
            return;
          }
        });
      };

      restartAnimation();
    }
  }, [enabled, iterationCount, value]);
  return enabled ? counterValue : value;
};

function useClipPathHash() {
  var _useState = useState(''),
      hash = _useState[0],
      setHash = _useState[1];

  useEffect(function () {
    setHash((Math.random() + 1).toString(36).substring(7));
  }, []);
  return hash;
}

var _excluded$2 = ["scale"];

var iconWidth = 16.8; // As per path

var iconHeight = 28.7;
function Charging(_ref) {
  var scale = _ref.scale,
      pathProps = _objectWithoutPropertiesLoose(_ref, _excluded$2);

  var _useGaugeContext = useGaugeContext(),
      canvasWidth = _useGaugeContext.canvasWidth,
      canvasHeight = _useGaugeContext.canvasHeight,
      orientation = _useGaugeContext.orientation,
      customization = _useGaugeContext.customization;

  var strokeWidth = customization[BATTERY_BODY].strokeWidth;
  var _customization$CHARGI = customization[CHARGING_FLASH],
      fill = _customization$CHARGI.fill,
      animated = _customization$CHARGI.animated,
      animationDuration = _customization$CHARGI.animationDuration;
  var animatedOpacityPer = useCounterAnimation({
    value: 100,
    enabled: animated,
    direction: 'both',
    iterationCount: 'infinite',
    duration: animationDuration,
    startValue: 20
  });

  var _useLevelDimensions = useLevelDimensions(),
      width = _useLevelDimensions.width;

  var iconXPos = width / 2 + iconWidth / 2;
  var iconYPos = canvasHeight / 2 - iconHeight / 2;
  var transformScale = scale ? "scale(" + scale + ")" : '';
  return React.createElement("g", {
    transform: orientation === 'vertical' ? "rotate(" + -90 + ")" + transformScale : transformScale,
    style: {
      transformOrigin: canvasWidth / 2 - strokeWidth + "px " + (canvasHeight / 2 - strokeWidth / 2) + "px"
    },
    opacity: animatedOpacityPer / 100
  }, React.createElement("path", Object.assign({
    d: "M" + iconXPos + "," + iconYPos + "l-13,16.8l7.4,0l-1.8,11.9l11.2,-16.8l-7.4,0l3.6,-11.9z",
    fill: fill
  }, pathProps)));
}

var _excluded$3 = ["size", "aspectRatio", "children", "padding", "value", "maxValue", "customization", "orientation", "animated", "charging", "formatValue"];
var BatteryGauge = function BatteryGauge(_ref) {
  var _customization$BATTER, _allCustomization;

  var _ref$size = _ref.size,
      size = _ref$size === void 0 ? 300 : _ref$size,
      _ref$aspectRatio = _ref.aspectRatio,
      aspectRatio = _ref$aspectRatio === void 0 ? defaultState.aspectRatio : _ref$aspectRatio,
      children = _ref.children,
      _ref$padding = _ref.padding,
      padding = _ref$padding === void 0 ? defaultState.padding : _ref$padding,
      _ref$value = _ref.value,
      value = _ref$value === void 0 ? defaultState.value : _ref$value,
      _ref$maxValue = _ref.maxValue,
      maxValue = _ref$maxValue === void 0 ? defaultState.maxValue : _ref$maxValue,
      _ref$customization = _ref.customization,
      customization = _ref$customization === void 0 ? defaultState.customization : _ref$customization,
      _ref$orientation = _ref.orientation,
      orientation = _ref$orientation === void 0 ? defaultState.orientation : _ref$orientation,
      _ref$animated = _ref.animated,
      animated = _ref$animated === void 0 ? defaultState.animated : _ref$animated,
      _ref$charging = _ref.charging,
      charging = _ref$charging === void 0 ? defaultState.charging : _ref$charging,
      _ref$formatValue = _ref.formatValue,
      formatValue = _ref$formatValue === void 0 ? function (value) {
    return value;
  } : _ref$formatValue,
      restSvgProps = _objectWithoutPropertiesLoose(_ref, _excluded$3);

  var canvasHeight = Math.round(CANVAS_WIDTH * aspectRatio);
  var height = Math.round(size * aspectRatio);
  var clipPathHash = useClipPathHash();
  var noLowBatteryColor = charging ? {
    lowBatteryFill: ((_customization$BATTER = customization[BATTERY_METER]) == null ? void 0 : _customization$BATTER.fill) || defaultState.customization[BATTERY_METER].fill
  } : {};
  var allCustomization = (_allCustomization = {}, _allCustomization[BATTERY_BODY] = _extends({}, defaultState.customization[BATTERY_BODY], customization[BATTERY_BODY]), _allCustomization[BATTERY_CAP] = _extends({}, defaultState.customization[BATTERY_CAP], customization[BATTERY_CAP]), _allCustomization[BATTERY_METER] = _extends({}, defaultState.customization[BATTERY_METER], customization[BATTERY_METER], noLowBatteryColor), _allCustomization[READING_TEXT] = _extends({}, defaultState.customization[READING_TEXT], customization[READING_TEXT]), _allCustomization[CHARGING_FLASH] = _extends({}, defaultState.customization[CHARGING_FLASH], customization[CHARGING_FLASH]), _allCustomization);
  var canvasPadding = allCustomization.batteryBody.strokeWidth / 2 + padding;
  var newValue = useCounterAnimation({
    value: value,
    enabled: animated
  });
  var chargingValue = useCounterAnimation({
    startValue: 1,
    value: maxValue,
    enabled: charging,
    iterationCount: 'infinite',
    duration: 2000
  });
  return React.createElement(Canvas, Object.assign({
    width: size,
    height: orientation === 'vertical' ? size : height,
    canvasWidth: CANVAS_WIDTH,
    canvasHeight: canvasHeight,
    padding: canvasPadding,
    value: charging ? chargingValue : newValue,
    maxValue: !maxValue ? 1 : maxValue,
    orientation: orientation,
    customization: allCustomization,
    clipPathHash: clipPathHash
  }, restSvgProps), React.createElement("g", {
    transform: orientation === 'vertical' ? "rotate(-90," + CANVAS_WIDTH / 2 + "," + canvasHeight / 2 + ")" // rotate at right top corner
    : ''
  }, React.createElement(Battery, null), React.createElement(BatteryLevel, null), charging ? React.createElement(Charging, null) : React.createElement(ReadingText, {
    formatValue: formatValue
  }), children));
};

export default BatteryGauge;
export { BatteryGauge };
//# sourceMappingURL=react-battery-gauge.esm.js.map
